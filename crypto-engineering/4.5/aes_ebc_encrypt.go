package main

import (
	"crypto/aes"
	"fmt"
	"os"
)

// xxd -p -r key.hex |xxd -i
var key []byte = []byte{
	0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
}

// xxd -p -r plaintext.hex |xxd -i
var plaintext []byte = []byte{
	0x62, 0x6c, 0x6f, 0x63, 0x6b, 0x20, 0x63, 0x69, 0x70, 0x68, 0x65, 0x72,
	0x73, 0x20, 0x20, 0x20, 0x68, 0x61, 0x73, 0x68, 0x20, 0x66, 0x75, 0x6e,
	0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x20, 0x78, 0x62, 0x6c, 0x6f, 0x63,
	0x6b, 0x20, 0x63, 0x69, 0x70, 0x68, 0x65, 0x72, 0x73, 0x20, 0x20, 0x20,
}

func main() {
	c, err := aes.NewCipher(key)
	if err != nil {
		fmt.Println()
		os.Exit(1)
	}

	bs := c.BlockSize()
	ciphertext := make([]byte, bs)
	for i := 0; i < len(plaintext); i += bs {
		c.Encrypt(ciphertext, plaintext[i:i+bs])
		os.Stdout.Write(ciphertext)
	}
}
